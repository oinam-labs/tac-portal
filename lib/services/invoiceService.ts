/**
 * Invoice Service
 * All invoice CRUD operations
 */

import { supabase } from '@/lib/supabase';
import { mapSupabaseError } from '@/lib/errors';
import { orgService } from './orgService';
import type { Database } from '@/lib/database.types';

type Invoice = Database['public']['Tables']['invoices']['Row'];
type InvoiceInsert = Database['public']['Tables']['invoices']['Insert'];
type InvoiceUpdate = Database['public']['Tables']['invoices']['Update'];

export interface InvoiceWithRelations extends Invoice {
    customer?: {
        id: string;
        name: string;
        phone: string;
        email: string | null;
        gstin: string | null;
        address: unknown;
    };
    shipment?: {
        id: string;
        awb_number: string;
        consignee_name: string;
        consignee_phone: string;
        consignee_address: unknown;
    };
}

export interface InvoiceFilters {
    status?: string;
    customerId?: string;
    search?: string;
    limit?: number;
}

export const invoiceService = {
    async list(filters?: InvoiceFilters): Promise<InvoiceWithRelations[]> {
        const orgId = orgService.getCurrentOrgId();

        let query = supabase
            .from('invoices')
            .select(`
        *,
        customer:customers(id, name, phone, email, gstin, address),
        shipment:shipments(id, awb_number, consignee_name, consignee_phone, consignee_address)
      `)
            .eq('org_id', orgId)
            .is('deleted_at', null)
            .order('created_at', { ascending: false });

        if (filters?.status) {
            query = query.eq('status', filters.status);
        }
        if (filters?.customerId) {
            query = query.eq('customer_id', filters.customerId);
        }
        if (filters?.search) {
            query = query.ilike('invoice_no', `%${filters.search}%`);
        }
        if (filters?.limit) {
            query = query.limit(filters.limit);
        }

        const { data, error } = await query;
        if (error) throw mapSupabaseError(error);
        return (data ?? []) as unknown as InvoiceWithRelations[];
    },

    async getById(id: string): Promise<InvoiceWithRelations> {
        const orgId = orgService.getCurrentOrgId();

        const { data, error } = await supabase
            .from('invoices')
            .select(`
        *,
        customer:customers(id, name, phone, email, gstin, address),
        shipment:shipments(id, awb_number, consignee_name, consignee_phone, consignee_address)
      `)
            .eq('id', id)
            .eq('org_id', orgId)
            .single();

        if (error) throw mapSupabaseError(error);
        return data as unknown as InvoiceWithRelations;
    },

    async getByInvoiceNo(invoiceNo: string): Promise<InvoiceWithRelations | null> {
        const orgId = orgService.getCurrentOrgId();

        const { data, error } = await supabase
            .from('invoices')
            .select(`
        *,
        customer:customers(id, name, phone, email, gstin, address),
        shipment:shipments(id, awb_number, consignee_name, consignee_phone, consignee_address)
      `)
            .eq('invoice_no', invoiceNo)
            .eq('org_id', orgId)
            .maybeSingle();

        if (error) throw mapSupabaseError(error);
        return data as unknown as InvoiceWithRelations | null;
    },

    async create(invoice: Omit<InvoiceInsert, 'org_id' | 'invoice_no'>): Promise<Invoice> {
        const orgId = orgService.getCurrentOrgId();

        // Invoice number is generated by the database

        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const { data, error } = await (supabase.from('invoices') as any)
            .insert({
                ...invoice,
                org_id: orgId,
            })
            .select()
            .single();

        if (error) throw mapSupabaseError(error);
        return data as Invoice;
    },

    async update(id: string, updates: InvoiceUpdate): Promise<Invoice> {
        const orgId = orgService.getCurrentOrgId();

        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const { data, error } = await (supabase.from('invoices') as any)
            .update({
                ...updates,
                updated_at: new Date().toISOString(),
            })
            .eq('id', id)
            .eq('org_id', orgId)
            .select()
            .single();

        if (error) throw mapSupabaseError(error);
        return data as Invoice;
    },

    async updateStatus(id: string, status: Invoice['status']): Promise<Invoice> {
        return this.update(id, { status });
    },

    async markPaid(id: string): Promise<Invoice> {
        return this.update(id, { status: 'PAID' });
    },

    async cancel(id: string): Promise<Invoice> {
        return this.update(id, { status: 'CANCELLED' });
    },

    async delete(id: string): Promise<void> {
        const orgId = orgService.getCurrentOrgId();

        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const { error } = await (supabase.from('invoices') as any)
            .update({ deleted_at: new Date().toISOString() })
            .eq('id', id)
            .eq('org_id', orgId);

        if (error) throw mapSupabaseError(error);
    },

    async getStats(): Promise<{
        total: number;
        issued: number;
        paid: number;
        overdue: number;
        totalAmount: number;
        paidAmount: number;
    }> {
        const orgId = orgService.getCurrentOrgId();

        const { data, error } = await supabase
            .from('invoices')
            .select('status, total')
            .eq('org_id', orgId)
            .is('deleted_at', null);

        if (error) throw mapSupabaseError(error);

        const invoices = data as Array<{ status: string; total: number }>;
        const stats = {
            total: invoices.length,
            issued: invoices.filter(i => i.status === 'ISSUED').length,
            paid: invoices.filter(i => i.status === 'PAID').length,
            overdue: invoices.filter(i => i.status === 'CANCELLED').length,
            totalAmount: invoices.reduce((sum, i) => sum + (i.total || 0), 0),
            paidAmount: invoices.filter(i => i.status === 'PAID').reduce((sum, i) => sum + (i.total || 0), 0),
        };

        return stats;
    },
};
